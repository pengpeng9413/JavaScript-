/**
 * 之前我们有学习过 节流和防抖  这之前的那篇中介绍过this ,这篇的话将更加细致的更加底层的来介绍  
 * js中 最隐晦的this ,知识水平有限，欢迎拍砖
 * 1. 首先我们来回答一个问题，什么是this?
 *    也许你很想知道，但是这个问题真的很难回答，this是个关键字，为啥造物主会产生它，它是来解决什么问题的，有什么作用？
 *    this提供了一种更优雅的方法来隐式'传递'一个对象的引用，因此可以将API设计得更加简洁并且易于复用
 *      
 *      
 */

 // 首先看看一个特别容易出错的题目
 function foo() {
    console.log(this.a);
  }
  
  var obj = {
    a: 2,
    foo: foo
  };
  
  var bar = obj.foo;  // 函数别名！
  var a = "oops, global"; // a是全局对象的属性
  bar();  //  "oops, global"  是不是跟你之前大脑想象的不太一样，你是不是之前以为输出的是 2 ，没错，之前我也是这么认为的

  /**
   * 回到刚才我们提到的问题：this的作用，它提供的了一种更加优雅隐晦的方法来传递 一个对象的引用
   * 我们来看下面的这段代码
   */
  function identify() {
    console.log("Hello,I'm " + this.name);
  }
  let me = {
    name: "Kyle"
  };
  let you = {
    name: "Reader"
  };
  identify.call(me); // Hello,I'm Kyle
  identify.call(you); // Hello,I'm Reader

  // 这个简单的栗子，可以在不同的对象中复用函数identify，不用针对每个对象编写一个新函数
  // 看到这里的时候，你是不是对  this 更加优雅的传递  一个对象的引用 有了更加深刻的理解
  // 引用 你不知道的js书中的一句话：随着你的使用模式越来越复杂的时候，显式传上下文对象，会让代码变得越来越混乱，
  // 使用this则不会这样，当我们介绍对象和原型的时，你就会明白函数可以自动引用合适的上下文有多么重要

  /** 
   * 回过头来，我们再来跟我们脑袋里的this的理解碰撞一下，我们常常对this有个误解：
   * 1. this 指向自身                                 =============错误！！
   *     
   * 2. this 指向函数的词法作用域                      =============错误！！
   *     需要指出的是：this在任何情况下都不指向函数的词法作用域，在函数内部，作用域确实和对象类似，可见的标识符都是他的属性
   *      。但是词法作用域“对象”无法通过js代码访问，，它存在于js引擎内部。
   */
  // 第二个误解，我们来看下面这个例子
  function foo (){
    var a=2
    this.bar();
  }
  function bar(){
    
    console.log(this.a)
  }
  foo() //   a is undefined  我们把词法作用域和this混在一块用了，这是万万不可以的

  /**
   * 经过上面这个例子，我们再来看看this是什么
   * this是运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用的各种条件。this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。
      当一个函数被调用时，会创建一个活动记录（也称执行上下文）。
      this既不指向函数本身，也不指向函数的词法作用域。
      他跟他的位置无关，是执行的时候绑定的
   */