/**
 * 之前我们有学习过 节流和防抖  这之前的那篇中介绍过this ,这篇的话将更加细致的更加底层的来介绍  
 * js中 最隐晦的this ,知识水平有限，欢迎拍砖
 * 1. 首先我们来回答一个问题，什么是this?
 *    也许你很想知道，但是这个问题真的很难回答，this是个关键字，为啥造物主会产生它，它是来解决什么问题的，有什么作用？
 *    this提供了一种更优雅的方法来隐式'传递'一个对象的引用，因此可以将API设计得更加简洁并且易于复用
 *      
 *      
 */

 // 首先看看一个特别容易出错的题目
 function foo() {
    console.log(this.a);
  }
  
  var obj = {
    a: 2,
    foo: foo
  };
  
  var bar = obj.foo;  // 函数别名！
  var a = "oops, global"; // a是全局对象的属性
  bar();  //  "oops, global"  是不是跟你之前大脑想象的不太一样，你是不是之前以为输出的是 2 ，没错，之前我也是这么认为的

  /**
   * 回到刚才我们提到的问题：this的作用，它提供的了一种更加优雅隐晦的方法来传递 一个对象的引用
   * 我们来看下面的这段代码
   */
  function identify() {
    console.log("Hello,I'm " + this.name);
  }
  let me = {
    name: "Kyle"
  };
  let you = {
    name: "Reader"
  };
  identify.call(me); // Hello,I'm Kyle
  identify.call(you); // Hello,I'm Reader

  // 这个简单的栗子，可以在不同的对象中复用函数identify，不用针对每个对象编写一个新函数
  // 看到这里的时候，你是不是对  this 更加优雅的传递  一个对象的引用 有了更加深刻的理解
  // 引用 你不知道的js书中的一句话：随着你的使用模式越来越复杂的时候，显式传上下文对象，会让代码变得越来越混乱，
  // 使用this则不会这样，当我们介绍对象和原型的时，你就会明白函数可以自动引用合适的上下文有多么重要

  /** 
   * 回过头来，我们再来跟我们脑袋里的this的理解碰撞一下，我们常常对this有个误解：
   * 1. this 指向自身                                 =============错误！！
   *     
   * 2. this 指向函数的词法作用域                      =============错误！！
   *     需要指出的是：this在任何情况下都不指向函数的词法作用域，在函数内部，作用域确实和对象类似，可见的标识符都是他的属性
   *      。但是词法作用域“对象”无法通过js代码访问，，它存在于js引擎内部。
   */
  // 第二个误解，我们来看下面这个例子
  function foo (){
    var a=2
    this.bar();
  }
  function bar(){
    
    console.log(this.a)
  }
  foo() //   a is undefined  我们把词法作用域和this混在一块用了，这是万万不可以的

  /**
   * 经过上面这个例子，我们再来看看this是什么
   * this是运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用的各种条件。this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。
      当一个函数被调用时，会创建一个活动记录（也称执行上下文）。
      this既不指向函数本身，也不指向函数的词法作用域。
      他跟他的位置（函数内部函数外部）无关，是执行的时候绑定的
      一个常见的陷阱是理所应当的认为函数调用中的，内部函数中 this 等同于它的外部函数中的 this。这也是错误的！！
   */

   
   /**
    * =========跟着你不知道的js，我们继续往下了解，=================
    * 书中有这么一句话： this 是在调用时被绑定的，完全取决于函数的调用位置（也就是函数的调用方法）。
    * 1. 调用位置：调用位置就是函数在代码中被调用的
          位置（而不是声明的位置）。只有仔细分析调用位置才能回答这个问题：这个 this 到底引用的是什么？
    *    以下呢，我们copy了一下你不知道的js的一些片段：
    */

//    通常来说，寻找调用位置就是寻找“函数被调用的位置”，但是做起来并没有这么简单，
// 因为某些编程模式可能会隐藏真正的调用位置。
// 最重要的是要分析调用栈（就是为了到达当前执行位置所调用的所有函数）。我们关心的
// 调用位置就在当前正在执行的函数的前一个调用中。
// 下面我们来看看到底什么是调用栈和调用位置：
    function baz() {
    // 当前调用栈是：baz
    // 因此，当前调用位置是全局作用域
    console.log( "baz" );
    bar(); // <-- bar 的调用位置
    }
    function bar() {
    // 当前调用栈是 baz -> bar
    // 因此，当前调用位置在 baz 中
    console.log( "bar" );
    foo(); // <-- foo 的调用位置
    }
    function foo() {
    // 当前调用栈是 baz -> bar -> foo
    // 因此，当前调用位置在 bar 中
    console.log( "foo" );
    }
    baz(); // <-- baz 的调用位置
    // 注意我们是如何（从调用栈中）分析出真正的调用位置的，因为它决定了 this 的绑定
    /* 
      我们来看看在函数的执行过程中调用位置如何决定 this 的绑定对象。
      你必须找到调用位置，然后判断需要应用下面四条规则中的哪一条。我们首先会分别解释
      这四条规则，然后解释多条规则都可用时它们的优先级如何排列。
      
      */
     /**
      * 1. 默认绑定
      * 本例中函数调用时应用了this的默认绑定，因为foo()是直接使用不带任何修饰的函数引用进行调用的，因此this指向全局对象。

      *：如果使用严格模式，则不能将全局对象用于默认绑定，因此this会绑定到undefined。
      **：对于默认绑定来说，决定this绑定对象的并不是调用位置是否处于严格模式，而是函数体是否处于严格模式。
      */
     function foo(){
      console.log(this.a);
    }
  
    var a=2;
    foo();//2
     /**
      * 2. 隐式绑定
      * 当foo()被调用时，它的前面确确实实加上了对obj的引用。
      * 当函数引用有上下文对象时，隐式绑定规则会把函数调用中的this绑定到这个上下文对象。
      * 因此调用foo()时this被绑定到obj，因此this.a和obj.a是一样的
      * 对象属性引用链中只有上一层或者说最后一层在调用位置中起作用
      * 
      * // 首先需要注意的是 foo() 的声明方式，及其之后是如何被当作引用属性添加到 obj 中的。
      // 但是无论是直接在 obj 中定义还是先定义再添加为引用属性，这个函数严格来说都不属于obj 对象。
      // 然而，调用位置会使用 obj 上下文来引用函数，因此你可以说函数被调用时 obj 对象“拥有”或者“包含”它
      */

      function foo(){
          console.log(this.a);
      }
      var obj={
          a:2,
          foo:foo
      };
      obj.foo();//2

      // 但是对象属性引用链中只有上一层或者说最后一层在调用位置中起作用怎么来理解呢？
      function foo() {
        console.log( this.a );
      }
      var obj2 = {
      a: 42,
      foo: foo
      };
      var obj1 = {
      a: 2,
      obj2: obj2
      };
      obj1.obj2.foo(); // 42

      /**
       * 3. 隐形丢失
       * 这里我们单独把隐形丢失拎了出来，因为这个实在是迷惑人，而且容易出错了，我们看下面这个例子
       */
      function foo() {
        console.log( this.a );
      }
      var obj = {
      a: 2,
      foo: foo
      };
      var bar = obj.foo; // 函数别名！
      var a = "oops, global"; // a 是全局对象的属性
      bar(); // "oops, global"

      // 虽然 bar 是 obj.foo 的一个引用，但是实际上，它引用的是 foo 函数本身，因此此时的 bar() 其实是一个不带任何修饰的函数调用，因此应用了默认绑定。
      // 更通俗的理解来说，其实obj只是倒了一边手，他并没有对foo()函数施加上下文对象的绑定，中间过了一边手，再取出来，
      // 相当于默认调用，等价于独立函数调用
      
      // 一种更微妙、更常见并且更出乎意料的情况发生在传入回调函数时
      function foo() {
        console.log( this.a );
      }
      function doFoo(fn) {
      // fn 其实引用的是 foo
      fn(); // <-- 调用位置！
      }
      var obj = {
      a: 2,
      foo: foo
      };
      var a = "oops, global"; // a 是全局对象的属性
      doFoo( obj.foo ); // "oops, global"
      // 如果你阅读了上面的常见陷阱，函数里面嵌套函数这样的位置关系是不会影响this指向的，同时理解了上面的隐形丢失，我相信这个理解会容易的多

      /**
       * 4. 显示绑定
       * 4.1 硬绑定 利用call ,apply 来绑定this
       * 4.2 软绑定 利用bind ，本质也是apply,再包裹一层罢了，详见 你不知道的js
       */
     
      function foo(){
        consol.log(this.a);
      }
    
      var obj={
          a:2
      };
    
      foo.call(obj);//2
      
      // 关于 bind,apply，call 改变this指向的问题，我们就不多做描述了，
      // 下面重点讲一下，api 调用的 ‘上下文’
      /**
       *  第三方库的许多函数，以及 JavaScript 语言和宿主环境中许多新的内置函数，都提供了一
      个可选的参数，通常被称为“上下文”（context），其作用和 bind(..) 一样，确保你的回调
      函数使用指定的 this 。
      举例来说：
       */
     
      function foo(el) {
      console.log( el, this.id );
      }
      var obj = {
      id: "awesome"
      };
      // 调用 foo(..) 时把 this 绑定到 obj
      [1, 2, 3].forEach( foo, obj );
      // 1 awesome 2 awesome 3 awesome
      // 这些函数实际上就是通过 call(..) 或者 apply(..) 实现了显式绑定，这样你可以少些一些
      // 代码。

      /**
       * 5. new() 绑定
       * * 这是最后一条this的绑定机制
       */
      // 说到new() 我们又要牵扯出 原型，构造函数，原型链三者之间的关系，不断涉及的肯定是js的基座与核心，我们需要不断的重复它理解他，内化它

      // 构造函数
      function Person(){

      }
      var person1=new Person() // 实例
      // 有以下关系
      person1.prototype.constructor=Person  //  实例的原型的构造函数会指向Person
      person1._proto_=Person.prototype      //  实例的原型链会指向该对象(Person)的原型

      // 事实上，其实并不存在“构造函数” 这一类特殊的函数，首先我们重新定义一下 JavaScript 中的“构造函数”。
      // 在 JavaScript 中，构造函数只是一些
      // 使用 new 操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上，
      // 它们甚至都不能说是一种特殊的函数类型，它们只是被 new 操作符调用的普通函数而已。
      // 实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”

      // 我们从上面的关系可以看出new() 到底做了啥？
      1. 创建或构造一个全新的对象
      2. 这个新对象会被执行原型链接  //  person1._proto_=Person.prototype 
      3. 这个新对象会绑定到函数调用的this  // 我们可以查看本项目中bind.js中的objectFactory（）函数，他是模拟new()的实现的
      4. 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。

      function foo(a) {
        this.a = a;
      }
      var bar = new foo(2);
      console.log( bar.a ); // 2

      // 看到输出结果，你肯定能理解上面  new() 操作符到底发生了什么，记住哦，上面的4步经常考
      //  领导来催活了，我们晚上接着写这个this
