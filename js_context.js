/**
 * @see 老生常谈，这节我们重新回过头再来看看js一些最基础的东西，执行上下文：context
 * @see  先来看下面这一道题
 * 
 */
var name='jack'
function isName(){
    console.log(name)  // undefined
    var name='xxp'
    console.log('name') // xxp
}
isName() // 输出啥？   对以上的输出结果会感到疑惑么？

/**
 * 在解决以上疑惑之前，我们先来介绍几个概念：
 * @see 1.作用域：指程序源代码中定义变量的区域，作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限
 *         javascript采用词法作用域，也就是下面会讲到的静态作用域 
 * @see 2.静态作用域：函数的作用域在函数定义的时候就决定了（JavaScript 采用的是词法作用域，即静态作用域）
 * @see 3.动态作用域：函数的作用域在函数调用的时候才决定
 * 为了更好的解释上面这两个概念,我们继续回到上面的例子
 */

 // ===1.0
var name='jack'
function change(){
    console.log(name)
}
change()

// 结果是？？？  答案是 ： jack
//====2.0====那么如果在这个函数的基础之上，我们改进一下==========
var name='jack'
function change(){
    console.log(name)
    var name='xxp'
}
change()

// 结果是？？？  答案是 ： undefined  ，
// ===3.0===我们在来变通一下
function change(){
    console.log(name)
}
change()
// 结果是？？？  答案是：抛错了

// ===4.0===我们再来变通一下
function change(){
    console.log(name)
}
change()
var name='jack'
// 结果是？？？ 答案是： undefined

//很神奇有木有?，很想知道答案有木有？很想搞清楚到底是怎么肥事有木有？
// ==========彭彭哥带你一探究竟！！

/**
 * @释一下上面的执行逻辑
 * @see 执行change()函数，js会先从change()函数内部查找是否有局部变量，
 * @see 如果没有，就根据书写的位置，查找上一层代码，于是在1.0中我们得到的答案是‘jack’,注意这里的描述，会向上查找！！这很关键
 * @see 因为我们在4.0中，外层代码也是有name的定义的，但是它不在change()函数的上层！因为只会向上查找。当然这只是我们从答案到自己总结的结论
 * @see 这里给出的结论的不一定对，只是归纳的，下面我们会对这其中涉及的知识点一个一个的展开讲！
 * 
 */


 /**
  * 1. 变量提升 
  * */
 console.log(a); // undefined
 var a='hi';
 console.log(a) // hi
 // -----以上写法等价于-----
 var a;
 console.log(a);  // undefined
 a='hi'
 console.log(a) // hi

 /**
  * @see 以前其实自己是有误区的，认为变量提升就是讲变量赋值放到作用域最顶上，这其实是错误的
  * @see 真正的变量提升的含义是：敲黑板！！----->变量声明会被提升到作用域最顶上,注意是声明不是赋值
  * @see 另外一个需要准确理解的是在js中，什么情况会出现undefined！！，undefined英文本意为未定义，但是你可能会奇怪，我变量声明了啊，
  * @see 为啥还是undefined呢，常规的来讲，声明了就代表了定义了啊！敲黑板！！！---->在计算机科学中
  * @see undefined通常用于指示变量尚未赋值，而不是未定义，也不是什么未声明，这不仅仅适用于js
  * @see 总的来说，我们需要记住下面这个结论：变量提升是变量声明提升，undefined通常用于指示变量尚未赋值，记住这两句话就够了
  */

  /* 在js中 undefined出现的原因有以下： */
  1.变量被声明了但是没有赋值
  2.调用函数时，应该提供的参数没有提供，该参数为undefined
  3.函数没有返回值时，默认返回undefined
  4.对象没有赋值的属性
  /* 在此也一并介绍一下undefined的难兄难弟null吧，null表示一个无的对象 ,null出现的原因有以下*/
  1.作为函数的参数，表示该函数的参数不是对象
  2.作为对象原型链的终点

  /* 为了加强理解，我们再来看一下这个例子 */
    console.log(a);//undefined
    console.log(b);//error
    var a = 10;
   // 等价于
    var a;
    console.log(a);
    console.log(b);
    a = 10;

/**
  * 1. 函数提升 
  * */

 console.log(a);//function a(){}
 var a = 10;
 function a(){
 
 }
 console.log(a);//10           ---------------对于这里的结果你是不是很吃惊，yhh,其实我也是，来看看究竟怎么肥事
 //===============> 变量的声明虽然在函数声明之前，但是函数优先被编译，实际代码是
   function a(){

    }
    console.log(a);
    a = 10;
    console.log(a);
 // 注意：这里的实际代码中是a = 10而不是var a = 10;因为函数声明不仅优先被编译了，还覆盖掉剩余的同名变量的声明。

 /**
  * @see 以上，我们得出结论：
  * @see 1.js的变量和函数在编译阶段会被提升到当前作用域最前面编译
  * @see 2.函数是一等公民，优先编译函数，且会覆盖同名变量的声明
  * @see 所以我们之前的总结归纳是理论不正确的，正确的理解应该是以变量提升和函数提升机制来解释
  */

  /**
   * 经过以上的知识点的学习，相信我们应对面试题应该是没什么问题了，现在我们进入一个更加抽象的话题
   * @see context执行上下文
   * @see 在将这个话题还是老样子，我们先来看这么一段代码
   */
  function foo(){
      console.log('foo1')
  }
  foo()
  function foo(){
      console.log("foo2")
  } 
  foo()
  // 打印的结果是两个 ‘foo2’
  // ----为啥是两个foo2呢？因为js引擎不是一行一行的分析和执行程序，而是一段一段的分析行。
  // ----当执行一段代码的时候，会进入一个准备工作，这些准备工作时啥呢？就会做变量声明提升，和函数提升
  // ----所以，其实上面的例子在实际js引擎解析执行中是这样的
  function foo(){
    console.log('foo1')
  }
  foo=function foo(){  // 会进行覆盖，需要注意的是同一作用域下存在多个同名函数声明，后面的会替换前面的函数声明
    console.log("foo2")
  }
  foo()
  foo()

  /**
   * @see 接下来我们再说一个概念：可执行代码
   * @see js的可执行代码类型就三种：全局代码，函数代码，eval()代码
   * @see 全局执行上下文： 这是默认的、最基础的执行上下文。不在任何函数中的代码都位于全局执行上下文中。它做了两件事：1. 创建一个全局对象，
   * 在浏览器中这个全局对象就是 window 对象。2. 将 this 指针指向这个全局对象。一个程序中只能存在一个全局执行上下文。
   *@see 函数执行上下文： 每次调用函数时，都会为该函数创建一个新的执行上下文。每个函数都拥有自己的执行上下文，
    但是只有在函数被调用的时候才会被创建。一个程序中可以存在任意数量的函数执行上下文。
    每当一个新的执行上下文被创建，它都会按照特定的顺序执行一系列步骤，具体过程将在本文后面讨论。
    *@see Eval 函数执行上下文： 运行在 eval 函数中的代码也获得了自己的执行上下文，但由于 Javascript 开发人员不常用 eval 函数，所以在这里不再讨论。


   * @see 举个例子，当执行到一个函数的时候，就会进行准备工作，这里的准备工作我们用一个更专业的词来表述它
   * @see 执行上下文
   * @see 什么是执行上下我，彭彭我看了很多文章，对其定义都是闪烁其词，我就来讲讲自己的理解吧啊，
   * @see 执行上下文就是当前javaScript代码被解析和执行时所在环境的抽象，一个抽象概念，
   * @see js代码中运行任何代码都是在执行上下文中运行
   * 更多有关于js执行上下文可参考阅文集团前端团队的这篇文章：https://juejin.im/post/5bdfd3e151882516c6432c32
   * 当然未完待续，彭彭这章还没有讲完，彭彭周末再跟你们絮叨js代码的执行机制，嘻嘻~
   */

  /* 这里我们再来联想一下我们之前学习的js中事件循环机制中的执行栈,联系我们今天学习的执行上下文，把知识点串联起来 */

  /**
   * @see 执行栈：执行栈在其他编程语言中也叫调用栈，具有LIFO(后进先出)结构，用于存储在代码执行期间创建的所有执行上下文
   * @see 当javascript引擎首次读取你的脚本的时候，它会创建一个全局执行上下文并将其推入当前的执行栈
   * @see 每当发生一个函数调用，引擎都会为该函数创建一个新的执行上下文并将其推入到当前执行栈的顶端
   * @see 引擎会运行执行上下文在执行栈中顶端的函数，当次函数执行完之后，其对应的执行上下文将会从执行栈中弹出，
   * @see 上下文的控制权将移交到当前执行栈的下一个执行上下文
   * @see 下面我们通过这么一个例子来理解这一点
   * 
   */
  let a = 'Hello World!';

  function first() {  
    console.log('Inside first function');  
    second();  
    console.log('Again inside first function');  
  }
  
  function second() {  
    console.log('Inside second function');  
  }
  
  first();  
  console.log('Inside Global Execution Context');
  
/* 当上述代码在浏览器中加载时，JavaScript 引擎会创建一个全局执行上下文并且将它推入当前的执行栈。
当调用 first() 函数时，JavaScript 引擎为该函数创建了一个新的执行上下文并将其推到当前执行栈的顶端。
当在 first() 函数中调用 second() 函数时，Javascript 引擎为该函数创建了一个新的执行上下文并将其推到当前执行栈的顶端。
当 second() 函数执行完成后，它的执行上下文从当前执行栈中弹出，
上下文控制权将移到当前执行栈的下一个执行上下文，即 first() 函数的执行上下文。
当 first() 函数执行完成后，它的执行上下文从当前执行栈中弹出，
上下文控制权将移到全局执行上下文。一旦所有代码执行完毕，Javascript 引擎把全局执行上下文从执行栈中移除。 */

/**
 * @see 执行上下文是如何被创建的
 * @see 以上呢，我们已经看到了javascript引擎如何管理执行上下文，现在我们来理解一下javascript引擎是如何创建上下文的
 * @see 执行上下文分为两个阶段创建：
 * @see 1)创建阶段
 * @see 2)执行阶段
 */

 /* 创建阶段 */
 /**，执行上下文处于创建阶段，在创建阶段总共发生了三件事情
  * @see 在任意的javaScript代码被执行前，执行上下文处于创建阶段，在创建阶段总共发生了三件事情
  * @see 1.确定this的值，也被称为（this Binding）即this的绑定
  * @see 2.LexicalEnvironment（词法环境） 组件被创建。
  * @see 3.VariableEnvironment（变量环境） 组件被创建
  */

  // 因此，执行上下文可以在概念上表示如下：
  
/*   
  ExecutionContext =
   {  
    ThisBinding = <this value>,  
    LexicalEnvironment = { ... },  
    VariableEnvironment = { ... },  
   } 
*/
/**
 * @see This Binding:
 * @see 在全局执行上下文中，this的值指向全局对象，在浏览器中，this的值指向window对象。
 * @see 在函数执行上下文中，this的值取决于函数的调用方式。如果它被一个对象引用调用，
 * @see 那么this的值被设置为该对象，否则this的值被设置为全局对象或undefined（严格模式下）。
很熟悉有没有，对就是我们之前复习的this的绑定那章，我们重点介绍了this的确定
 */

/**
 * @see 词法环境
 * @see  (未完待续，后面的概念比较艰涩抽象，但是我们还是得好好的去理解一下他，始终是绕不过去的)
 */

